1. Что такое блочный элемент
// Это элемент, который отображается ввиде прямоугольника, он занимает всю доступную ширину, а высота зависит от содержимого. 
Начинается всегда с новой строки. <div>, <h1>, <p>

2. Зачем нужны классы и индетификаторы, в чем отличие
// Идентификаторы нужны чтобы задавать стили и получать доступ к элементу. Классы нужны чтобы задавать стили.
Отличия: 1. идентификатор уникален, классы нет. 2. Доступ к элементу по id и изменение свойств. 3. Стили для id приоритетнее, чем для класса. 4. У элемента может быть несколко классов, но один идентификатор

3. Что такое область видимости, какие бываю в JS
// Область видимости переменной это область, в которой эта переменная доступна. Бывают глобальная, блочная, функциональная, модульная. Области видимости могут быть вложенными.
У функций есть лексическая область видимости (замыкание). 

4. Методы перебора массива с кратким описанием
// 1. forEach(callback) - для каждого элемента массива применяет функцию-callback, не возвращает новый массив.
2. filter(callback) - возвращает новый массив, с элементами для которых callback возвращает true
3. map(callback) - создает новый массив, с новыми элементами - результатами действия callback для каждого элемента.
4. reduce(callback, initialValue - не обязательно) - возвращает накопленное значение, после применения callback для каждого элемента.
5. every(callback) - возвращает true, если для каждого элемента callback вернет true.
6. some(callback) - возвращает true, если для какого-нибудь элемента callback вернет true.

5. Что означает ключевое слово this
// this это ссылка на обьект(контекст выполнения функции). значение this зависит от того как вызвана и создана функция. стрелочные функции не имеют своего this и this будет привязан к окружению где была создана функция.
в глобальной области видимости this ссылается на обьект window. this метода обьекта ссылается на сам обьект (если не стрелочная функция). Существуют методы call, aplly, bind которые меняют this для функции.

6. Какие данные лучше хранить в состоянии компонента, а какие передавать через пропсы, приведите пример
// 1) Данные, которые генерируются в родительском компоненте и нужны дочернему компоненту надо передавать через пропсы 
(например, данные по машине Сar получаются с сервера или задаются пользователем в родительском компоненте <CarData /> и передаются в дочерний компонент <CarInfo carName={Car.carName} />.
2) Данные, которые компонент должен изменить в какой-то момент времени (например после нажатия кнопки пользователем), должны быть в состоянии (например, данные по машине Сar в компоненте <CarData />
3) Если данные можно вычислить в своем компоненте на основе других данных и пропсов, тогда эти данные не должны быть состоянием.

7. Задача1. Свой Array.prototype.reduce. Написать свою функцию аналог. первым параметром функция принимает массив, вторым колбэк, третьим - начальное значение, использовать reduce запрещено

8. Задача2. Максимальное кол-во слов. Дан массив предложений. в предложении слова разделены пробелами. необходимо написать функцию, которая вернет максимальное число слов в одном предложении. 
Пример: 
Вход: const arr=["hello world", "This is a great solution", "How are you"]
Ответ: 5